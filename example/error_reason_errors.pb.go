// Code generated by protoc-gen-go-errors. DO NOT EDIT.

package example

import (
	fmt "fmt"
	errors "github.com/go-kratos/kratos/v2/errors"
	runtime "runtime"
	strconv "strconv"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
const _ = errors.SupportPackageIsVersion1

type ErrorReasonErrors struct {
	code    int
	reason  string
	message string
	i18n    map[string]string
	err     error
	args    []interface{}
	lang    string
	line    string
}

func (e *ErrorReasonErrors) Error() *errors.Error {
	metadata := map[string]string{}
	if e.err != nil {
		metadata["cause"] = e.err.Error()
	}
	if e.line != "" {
		metadata["line"] = e.line
	}
	message := e.message
	if e.lang != "" {
		if _, ok := e.i18n[e.lang]; ok {
			message = e.i18n[e.lang]
		}
	}
	if len(e.args) > 0 {
		message = fmt.Sprintf(message, e.args...)
	}
	return errors.New(e.code, e.reason, message).WithMetadata(metadata)
}

type Option func(gen *ErrorReasonErrors)

func WithError(err error) Option {
	return func(e *ErrorReasonErrors) {
		e.err = err
	}
}

func WithFmtMsg(args ...interface{}) Option {
	return func(e *ErrorReasonErrors) {
		e.args = args
	}
}

func WithLine() Option {
	var fileLine string
	_, file, line, ok := runtime.Caller(2)
	if ok {
		fileLine = file + ":" + strconv.Itoa(line)
	}
	return func(e *ErrorReasonErrors) {
		e.line = fileLine
	}
}

func WithI18N(lang string) Option {
	return func(e *ErrorReasonErrors) {
		e.lang = lang
	}
}

func IsBadRequest(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_BAD_REQUEST.String() && e.Code == 400
}

func ErrorBadRequest(format string, args ...interface{}) *errors.Error {
	return errors.New(400, ErrorReason_BAD_REQUEST.String(), fmt.Sprintf(format, args...))
}

func ErrorReasonBadRequest(opts ...Option) *errors.Error {
	e := &ErrorReasonErrors{
		code:    400,
		reason:  ErrorReason_BAD_REQUEST.String(),
		message: "BAD_REQUEST",
		i18n: map[string]string{
			"en_US": "Bad request",
			"zh_CN": "错误的请求",
		},
	}
	for _, o := range opts {
		o(e)
	}
	return e.Error()
}

func IsUnauthorized(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_UNAUTHORIZED.String() && e.Code == 401
}

func ErrorUnauthorized(format string, args ...interface{}) *errors.Error {
	return errors.New(401, ErrorReason_UNAUTHORIZED.String(), fmt.Sprintf(format, args...))
}

func ErrorReasonUnauthorized(opts ...Option) *errors.Error {
	e := &ErrorReasonErrors{
		code:    401,
		reason:  ErrorReason_UNAUTHORIZED.String(),
		message: "UNAUTHORIZED",
		i18n: map[string]string{
			"en_US": "Unauthorized",
			"zh_CN": "未经授权",
		},
	}
	for _, o := range opts {
		o(e)
	}
	return e.Error()
}

func IsForbidden(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_FORBIDDEN.String() && e.Code == 403
}

func ErrorForbidden(format string, args ...interface{}) *errors.Error {
	return errors.New(403, ErrorReason_FORBIDDEN.String(), fmt.Sprintf(format, args...))
}

func ErrorReasonForbidden(opts ...Option) *errors.Error {
	e := &ErrorReasonErrors{
		code:    403,
		reason:  ErrorReason_FORBIDDEN.String(),
		message: "FORBIDDEN",
		i18n: map[string]string{
			"en_US": "Forbidden",
			"zh_CN": "禁止访问",
		},
	}
	for _, o := range opts {
		o(e)
	}
	return e.Error()
}

func IsNotFound(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_NOT_FOUND.String() && e.Code == 404
}

func ErrorNotFound(format string, args ...interface{}) *errors.Error {
	return errors.New(404, ErrorReason_NOT_FOUND.String(), fmt.Sprintf(format, args...))
}

func ErrorReasonNotFound(opts ...Option) *errors.Error {
	e := &ErrorReasonErrors{
		code:    404,
		reason:  ErrorReason_NOT_FOUND.String(),
		message: "NOT_FOUND",
		i18n: map[string]string{
			"en_US": "Not found",
			"zh_CN": "资源未找到",
		},
	}
	for _, o := range opts {
		o(e)
	}
	return e.Error()
}

func IsMethodNotAllowed(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_METHOD_NOT_ALLOWED.String() && e.Code == 405
}

func ErrorMethodNotAllowed(format string, args ...interface{}) *errors.Error {
	return errors.New(405, ErrorReason_METHOD_NOT_ALLOWED.String(), fmt.Sprintf(format, args...))
}

func ErrorReasonMethodNotAllowed(opts ...Option) *errors.Error {
	e := &ErrorReasonErrors{
		code:    405,
		reason:  ErrorReason_METHOD_NOT_ALLOWED.String(),
		message: "METHOD_NOT_ALLOWED",
		i18n: map[string]string{
			"en_US": "Method not allowed",
			"zh_CN": "方法不允许",
		},
	}
	for _, o := range opts {
		o(e)
	}
	return e.Error()
}

func IsRequestTimeout(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_REQUEST_TIMEOUT.String() && e.Code == 408
}

func ErrorRequestTimeout(format string, args ...interface{}) *errors.Error {
	return errors.New(408, ErrorReason_REQUEST_TIMEOUT.String(), fmt.Sprintf(format, args...))
}

func ErrorReasonRequestTimeout(opts ...Option) *errors.Error {
	e := &ErrorReasonErrors{
		code:    408,
		reason:  ErrorReason_REQUEST_TIMEOUT.String(),
		message: "REQUEST_TIMEOUT",
		i18n: map[string]string{
			"en_US": "Request timeout",
			"zh_CN": "请求超时",
		},
	}
	for _, o := range opts {
		o(e)
	}
	return e.Error()
}

func IsConflict(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_CONFLICT.String() && e.Code == 409
}

func ErrorConflict(format string, args ...interface{}) *errors.Error {
	return errors.New(409, ErrorReason_CONFLICT.String(), fmt.Sprintf(format, args...))
}

func ErrorReasonConflict(opts ...Option) *errors.Error {
	e := &ErrorReasonErrors{
		code:    409,
		reason:  ErrorReason_CONFLICT.String(),
		message: "CONFLICT",
		i18n: map[string]string{
			"en_US": "Conflict",
			"zh_CN": "资源冲突",
		},
	}
	for _, o := range opts {
		o(e)
	}
	return e.Error()
}

func IsInternalServerError(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_INTERNAL_SERVER_ERROR.String() && e.Code == 500
}

func ErrorInternalServerError(format string, args ...interface{}) *errors.Error {
	return errors.New(500, ErrorReason_INTERNAL_SERVER_ERROR.String(), fmt.Sprintf(format, args...))
}

func ErrorReasonInternalServerError(opts ...Option) *errors.Error {
	e := &ErrorReasonErrors{
		code:    500,
		reason:  ErrorReason_INTERNAL_SERVER_ERROR.String(),
		message: "INTERNAL_SERVER_ERROR",
		i18n: map[string]string{
			"en_US": "Internal server error",
			"zh_CN": "内部服务器错误",
		},
	}
	for _, o := range opts {
		o(e)
	}
	return e.Error()
}

func IsNotImplemented(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_NOT_IMPLEMENTED.String() && e.Code == 501
}

func ErrorNotImplemented(format string, args ...interface{}) *errors.Error {
	return errors.New(501, ErrorReason_NOT_IMPLEMENTED.String(), fmt.Sprintf(format, args...))
}

func ErrorReasonNotImplemented(opts ...Option) *errors.Error {
	e := &ErrorReasonErrors{
		code:    501,
		reason:  ErrorReason_NOT_IMPLEMENTED.String(),
		message: "NOT_IMPLEMENTED",
		i18n: map[string]string{
			"en_US": "Not implemented",
			"zh_CN": "未实现",
		},
	}
	for _, o := range opts {
		o(e)
	}
	return e.Error()
}

func IsBadGateway(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_BAD_GATEWAY.String() && e.Code == 502
}

func ErrorBadGateway(format string, args ...interface{}) *errors.Error {
	return errors.New(502, ErrorReason_BAD_GATEWAY.String(), fmt.Sprintf(format, args...))
}

func ErrorReasonBadGateway(opts ...Option) *errors.Error {
	e := &ErrorReasonErrors{
		code:    502,
		reason:  ErrorReason_BAD_GATEWAY.String(),
		message: "BAD_GATEWAY",
		i18n: map[string]string{
			"en_US": "Bad gateway",
			"zh_CN": "错误的网关",
		},
	}
	for _, o := range opts {
		o(e)
	}
	return e.Error()
}

func IsServiceUnavailable(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_SERVICE_UNAVAILABLE.String() && e.Code == 503
}

func ErrorServiceUnavailable(format string, args ...interface{}) *errors.Error {
	return errors.New(503, ErrorReason_SERVICE_UNAVAILABLE.String(), fmt.Sprintf(format, args...))
}

func ErrorReasonServiceUnavailable(opts ...Option) *errors.Error {
	e := &ErrorReasonErrors{
		code:    503,
		reason:  ErrorReason_SERVICE_UNAVAILABLE.String(),
		message: "SERVICE_UNAVAILABLE",
		i18n: map[string]string{
			"en_US": "Service unavailable",
			"zh_CN": "服务不可用",
		},
	}
	for _, o := range opts {
		o(e)
	}
	return e.Error()
}

func IsGatewayTimeout(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_GATEWAY_TIMEOUT.String() && e.Code == 504
}

func ErrorGatewayTimeout(format string, args ...interface{}) *errors.Error {
	return errors.New(504, ErrorReason_GATEWAY_TIMEOUT.String(), fmt.Sprintf(format, args...))
}

func ErrorReasonGatewayTimeout(opts ...Option) *errors.Error {
	e := &ErrorReasonErrors{
		code:    504,
		reason:  ErrorReason_GATEWAY_TIMEOUT.String(),
		message: "GATEWAY_TIMEOUT",
		i18n: map[string]string{
			"en_US": "Gateway timeout",
			"zh_CN": "网关超时",
		},
	}
	for _, o := range opts {
		o(e)
	}
	return e.Error()
}
